Часто вам проще управлять временем, когда вы выполняете задачу только одного
вида (правите эти 12 ошибок(bugs)), чем, когда вы имеете несколько их
(исправляете эти ошибки, проводите интервью с кандидатами на замену
системного администратора, оценивание производительность вашей команды, и

создаёте слайды для презентации на следующей неделе). Когда вы заняты задачей
только одного вида, вы можете начать сверху вороха и взять её в работу, и так до
тех пор, пока вся куча не будет разобрана; (или вы); вам нет необходимости
затрачивать мыслительную энергию для понимания, какая работа будет
следующей. С другой стороны, управление множеством приоритетов и сроков и
переключение от задачи к задаче обычно вносит накладные расходы.
Также это справедливо и для программного обеспечения: программа, которая
последовательно выполняет только один тип задач, проще в написании, менее
подвержена ошибкам, и проще в тестировании, чем одна, управляющая
множеством различных типов задач за раз. Назначение потоков каждому типу
задач, или даже элементам, в симуляции создаёт иллюзию последовательности и
изолированности логики домена (domain logic) от деталей планирования,
чередования операций, асинхронного ввода/вывода, и ожидания ресурсов.
Сложные, асинхронные рабочие процессы (workflows) могут быть разбиты на
конечное количество простых, синхронных рабочих процессов, каждый из которых
запущен в отдельном потоке, взаимодействующих друг с другом только в
определённых точках синхронизации (synchronization points).
Эти преимущества часто эксплуатируются фрэймворками, такими как сервлеты
или RMI (удалённый вызов процедур). Фреймворки берут на себя детали
управления запросами, создания потоков, балансировкой нагрузки,
диспетчеризуют порции запросов обрабатываемых соответствующими
компонентами приложения в соответствующих точках рабочего процесса. Тем, кто
пишет сервлеты, нет необходимости беспокоится о том, как много запросов будет
обработано в один момент времени или о блоке ввода и вывода сокета; когда
сервисный метод сервлета (service method) вызывается в ответ на веб-запрос, он
может обрабатывать запрос асинхронно, как если бы это была однопоточная
программа. Это может упростить разработку компонентов и снизить кривую
обучения для использования фрэймворков.