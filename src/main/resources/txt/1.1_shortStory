В давнем прошлом, компьютеры не имели операционных систем; они
выполняли единственную программу от начала и до конца, и программа имела
прямой доступ ко всем ресурсам машины. Писать программы, которые работали на
голом железе, было не единственной сложностью, другой была возможность
запуска за раз только одной программы, что вызывало неэффективное
использование дорогостоящих и ограниченных ресурсов компьютера.
Эволюционировав, операционные системы позволили запускать более одной
программы за раз, запуская программы в индивидуальных процессах:
изолированных, независимо выполняемых программах, для которых операционная
система выделает ресурсы, такие как память, указатели на файлы и ограничения
системы безопасности. Также, если необходимо, процессы могут
взаимодействовать с другими процессами через различные механизмы
коммуникации: сокеты, обработчики сигналов, разделяемую память, семафоры и
файлы.
Несколько мотивирующих факторов привели к разработке операционных
систем, которые позволяли одновременно выполнять несколько программ:
Использование ресурсов. Программы иногда вынуждены ожидать завершения
внешних операций, таких как ввод или вывод, и пока длится ожидание, не
могут выполнять полезную работу. Гораздо эффективнее использовать время
ожидания, позволив выполняться другой программе.
Справедливость. Множество ресурсов и программ могут иметь эквивалентные
запросы к ресурсам машины. Предпочтительно позволить им разделять
ресурсы компьютера на равно-порционные куски времени, чем ожидать
завершения одной программы и запускать другую
Удобство. Часто проще и предпочтительнее написать несколько программ, каждая
из которых выполняет одну задачу и имеет возможность координироваться с
другими (если это необходимо), чем написать одну программу, которая
выполняет сразу все задачи.
В ранних системах с разделением времени, каждый процесс являлся
виртуальным Фон-Неймановским компьютером, он имел пространство в памяти

для совместного хранения инструкций и данных, выполнялись инструкции
последовательно, в соответствии с семантикой языка машины, и
взаимодействовали с внешним миром через набор примитивов ввода/вывода
операционной системы. Для каждой выполняемой инструкции была четко
определена «следующая инструкция» и контроль потока выполнения программы
осуществлялся строго в соответствии с правилами набора инструкций. Почти все
широко используемые сегодня языки программирования следуют этой
последовательной программной модели, где спецификация языка
программирования чётко определяет, «что последует далее» после выполнения
некоторой команды.
Модель последовательного программирования интуитивна и естественна, и,
фактически повторяет модель работы человека: делать по одной вещи в один
момент времени, в основном – последовательно. Встать с постели, облачится в
халат, спустится вниз и приготовить чай. Как и в языках программирования,
каждое из действий реального мира является абстракцией для последовательности
небольших действий - открыть шкаф, выбрать сорт чая, отмерить некоторое
количество в чайник, проверить, достаточно ли в чайнике воды, если нет, то долить
немного воды в него, поставить чайник на плиту, ожидать пока вода закипит, и так
далее. Этот последний шаг – ожидание, пока закипит вода – предполагает
некоторую степень асинхронности (asynchrony). Пока вода нагревается, вы можете
выбрать, что делать – просто подождать, или выполнить другую задачу в это время,
такую как начать жарить тосты (другая асинхронная задача) или почитать новости,
учитывая, что в скором времени вашего внимания потребует чайник.
Производители чайников и тостеров знают, что их продукты часто используются в
асинхронной манере, поэтому устройства подают звуковой сигнал, когда
завершают свою работу. Поиск правильной балансировки последовательных и
асинхронных действий часто является характеристикой эффективного человека –
это также справедливо для программ.
То же самое (утилизация ресурсов, справедливое распределение и удобство) что
мотивировал разработку процессов, также мотивировало разработку потоков
(threads). Потоки позволяют нескольким потокам управления программным
потоком (control flow) сосуществовать в процессе. Они разделяют общие ресурсы
процесса, такие как память и указатели на файлы, о каждый поток имеет свой
собственный программный счётчик, стек, и локальные переменные. Потоки также
предоставляют естественный механизм декомпозиции для использования
аппаратного параллелизма в многопроцессорных системах; множество потоков
внутри программы могут быть запущены одновременно на множество ЦПУ.
Потоки иногда называют легковесными процессами, и большинство
современных операционных систем рассматривают потоки, не процессы, как
простейшие единицы планирования. В отсутствие явной координации, потоки
выполняются одновременно и асинхронно относительно друг друга. С момента
обращения потоков к общей разделяемой памяти собственного процесса, все
потоки внутри процесса имеют доступ к переменным и выделяют объекты из кучи
(heap), которая позволяет организовать более изящное совместное использование
данных (data sharing), чем механизмы межпроцессного взаимодействия. Но без
явной синхронизации для координации доступа к совместно используемым
данным, поток может изменить переменную, пока другой поток находится в
процессе использования переменной (in the middle of using), что приведёт к
непредсказуемым результатам.