Серверное приложение, принимающее подключения сокетов от множества
удалённых клиентов может быть проще в разработке, когда под каждое
подключение выделяется собственный поток и в нём позволяется использовать
синхронный ввод/вывод.
Если приложение приступает к чтению из сокета, когда данные недоступны,
блоки будут считываться до тех пор, пока данные не станут доступны. В
однопоточном приложении это значит, что приостановится не только обработка
соответствующего запроса, но будет приостановлена обработка всех запросов, пока
один поток заблокирован. Для обхода этой проблемы, однопоточные серверные
приложения вынуждены использовать неблокирующий ввод/вывод, который
намного сложнее и более подвержен ошибкам, чем синхронные операции
ввода/вывода. Однако, если каждый запрос имеет свой собственный поток, тогда
блокировка не оказывает влияние на обработку других запросов.
Исторически так сложилось, что операционные системы располагали
относительно низким лимитом на количество потоков, которые мог создать
процесс, всего несколько сотен (или даже меньше). В результате операционные
системы разработали эффективные средства для мультиплексированного
ввода/вывода, такие как системные вызовы UNIX select и poll, и для доступа к этим
средствам библиотекой классов Java был добавлен набор пакетов (java.nio) для
неблокирующего ввода/вывода. Тем не менее, операционные системы стали
поддерживать значительно большее количество потоков, таким образом,
предоставив возможность практической реализации модели отдельный-поток-для-
каждого-клиента, даже для большого количества клиентов для некоторых
платформ