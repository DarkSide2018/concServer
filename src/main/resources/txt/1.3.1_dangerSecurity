Потокобезопасность может быть неожиданно тонким понятием: из-за отсутствия
достаточной синхронизации, порядок операций во множестве потоков
непредсказуем и иногда случаются сюрпризы. Класс UnsafeSequence в листинге
1.1, который должен генерировать последовательность уникальных целых чисел,
предлагает простую иллюстрацию того, как чередование действий в множестве
потоков может к нежелательным результатам. Он ведёт себя корректно в пределах
однопоточного окружения, но в многопоточном окружении всё иначе.
@NotThreadSafe
public class UnsafeSequence {
private int value;
/* Returns a unique value. */
public int getNext() {
return value++;
}
}

Листинг 1.1 Непотокобезопасный генератор последовательностей.

Проблема с UnsafeSequence возникает в неудачный момент времени, два потока
могут вызвать getNext и получить некоторое значение. На рис. 1.1 показано, как
это может произойти. Нотация инкремента, someVariable++, может казаться
единой операцией, но это фактически три раздельных операции: чтения значения,
добавления единички к нему, и запись нового значения в переменную. Так как
операции в множестве потоков могут произвольно чередоваться во время
выполнения, вполне возможно для двух потоков прочитать значения в один момент
времени, и затем добавить по единичке к ним. В результате один и тот же
порядковый номер возвращается из нескольких вызовов в разных потоках.

Рис. 1.1 Неудачное выполнение UnsafeSequence.getNext.

Диаграммы на рис. 1.1 показывают возможное чередование операций в
различных потоках. На этих диаграммах, движется слева направо, и каждая
линия представляет активность различных потоков. Эти чередующиеся
value → 9 9 + 1 → 10 value → 10

value → 9 9 + 1 → 10 value → 10

A

B

диаграммы обычно показывают наихудший случай4 и предназначены для
того, чтобы показать опасность неверного предположения, о том, что все
произойдет в строго определенном порядке.
Класс UnsafeSequence использует нестандартную аннотацию:
@NotThreadSafe. Это одна из нескольких пользовательских аннотаций,
используемых на протяжении всей книги, для документирования параллелизма
свойств и членов классов. (Аналогичным образом используются другие аннотации
уровня класса - @ThreadSafe и @Immutable; см. Приложение А) Аннотации,
документирующие потокобезопасность, полезны для нескольких аудиторий. Если
классы аннотированы с помощью @ThreadSafe, пользователи могут с
уверенностью использовать их в многопоточном окружении, со своей стороны,
разработчик ставит в известность, что потокобезопасность гарантирована и должна
быть сохранена, и инструменты для анализа кода могут определить возможные
ошибки кодирования.
Класс UnsafeSequence показывает распространённую проблему параллелизма,
называемую условием гонок (race condition). Возвращает ли getNext уникальное
значение при вызове из нескольких потоков, как того требует спецификация, или
нет, зависит от того, как среда выполнения (runtime) чередует операции - это
является нежелательным состоянием дел.
Из-за того, что потоки разделяют общее адресное пространство и запускаются
параллельно, они могут получать доступ и модифицировать те переменные,
которые могут использовать другие потоки. Это потрясающе удобно, потому что
позволяет совместно использовать данные проще, чем в любых других
межпоточных механизмах коммуникации. Но, такой механизм коммуникации,
также несёт в себе значительные риски: потоки могут быть дискредитированы
(confused) при неожиданном изменении данных. Возможность множества потоков
получить доступ и модифицировать некоторые переменные вводит элемент
непоследовательности в последовательную модель программирования, что может
сбивать с толку и быть сложным для понимания. Для многопоточных программ
поведение должно быть предсказуемым, доступ к совместно используемым (shared)
переменным должен быть правильно скоординирован так, чтобы потоки не
вмешивались в работу друг друга. К счастью, Java предоставляет механизмы
синхронизации для координации такого доступа.
Класс UnsafeSequence может быть исправлен путём превращения метода
getNext в синхронизированный (synchronized), как показано в листинге 1.25
, тем
самым предотвращая неудачное взаимодействие как на рис. 1.1. (Подробно о том,
как это работает, является темой глав 2 и 3)
@ThreadSafe
public class Sequence {
@GuardedBy("this") private int value;
public synchronized int getNext() {
return value++;
4 Фактически, как мы увидим в Главе 3, наихудший случай может быть ещё сложнее, чем обычно
показывается на этих диаграммах, из-за возможности переупорядочивания.
5 Аннотация @GuardedBy описывается в секции 2.4; Она документирует политику синхронизации
(synchronization policy) для класса Sequence.

}
}

Листинг 1.2. Потокобезопасный генератор последовательности
В отсутствие синхронизации, компилятору, железу и среде выполнения
позволяются существенные вольности в обращении с таймингами и порядком
выполнения действий, такие как кэширование переменных в регистрах или в
локальных кэшах процессора, где они временно (или даже постоянно) недоступны
для других потоков. Эти ухищрения помогают улучшить производительность, и в
общем случае желательны, но они возлагают бремя ответственности за чёткое
обозначение того, где данные должны совместно использоваться между потоками,
на разработчика, который должен сделать так, чтобы эти оптимизации не
подрывали безопасность. В главе 16 приводятся подробные сведения о том, как
именно JVM гарантирует порядок и какое влияние оказывает синхронизация на эти
гарантии, но если вы последуете правилам в главах 2 и 3, то можете свободно
опустить эти низкоуровневые подробности.